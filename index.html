

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
         <title>sllidebar</title>
         <body>
            <body text="black" background="C:\Users\dell\Downloads\colorful-abstract-background-free-vector.jpg"> 
              
                
         <p><h1><center><bold><marquee>FIREFOX Wikipedia</marquee></bold></center></h1></p>
         <img src="C:\Users\dell\Downloads\firefoxpng.jpg"  width="30%"> <br>

          <br>
          <br>
          <br>

         Enter your name:

<input type="text" name="UserName" size=35 maxlength=35 value="">

</br></br>
         <h1><i>Mozilla Firefox, or simply Firefox, is a free and open-source[19] web browser developed by the Mozilla Foundation and its subsidiary, the Mozilla Corporation. It uses the Gecko rendering engine to display web pages, which implements current and anticipated web standards.[20] In November 2017, Firefox began incorporating new technology under the code name "Quantum" to promote parallelism and a more intuitive user interface.[21] Firefox is available for Windows 7 and later versions, macOS, and Linux. Its unofficial ports are available for various Unix and Unix-like operating systems, including FreeBSD,[8] OpenBSD,[9] NetBSD,[10] illumos,[11] and Solaris Unix.[13] It is also available for Android and iOS. However, as with all other iOS web browsers, the iOS version uses the WebKit layout engine instead of Gecko due to platform requirements. An optimized version is also available on the Amazon Fire TV as one of the two main browsers available with Amazon's Silk Browser.[22]

            Firefox was created in 2002 under the code name "Phoenix" by members of the Mozilla community who desired a standalone browser rather than the Mozilla Application Suite bundle. During its beta phase, it proved to be popular with its testers and was praised for its speed, security, and add-ons compared to Microsoft's then-dominant Internet Explorer 6. It was released on November 9, 2004,[23] and challenged Internet Explorer's dominance with 60 million downloads within nine months.[24] It is the spiritual successor of Netscape Navigator, as the Mozilla community was created by Netscape in 1998, before their acquisition by AOL.[25]
            
            Firefox usage share grew to a peak of 32.21% in November 2009,[26] with Firefox 3.5 overtaking Internet Explorer 7, although not all versions of Internet Explorer as a whole;[27][28] its usage then declined in competition with Google Chrome.[26] As of December 2022, according to StatCounter, it had a 7.1% usage share as a desktop web browser, making it the fourth-most popular desktop web browser after Google Chrome (66.1%), Microsoft Edge (11.2%), and Safari (9.6%).[29] Across all platforms, it again places fourth with a usage share of 3.04%.[30]</i></h1>
        
        <h1><center>how to use mozilla fire fox </center></h1>
         <h3>IF YOU WANT TO USE YOU CAN GO DOWN  AND CHECK IT  IN YOUTUBE video</h3>



            <iframe  ="" width="560" height="315" src="https://www.youtube.com/embed/rrFiiph0eMo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
         <h1> FOUNDER OF FIREFOX </h1>
         <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/Brendan_Eich_Mozilla_Foundation_official_photo.jpg/800px-Brendan_Eich_Mozilla_Foundation_official_photo.jpg" width="60%" height="80%">
         <img src="http://t0.gstatic.com/licensed-image?q=tbn:ANd9GcQz-w9esY0FbcHdx3bzbdpYbMKOYeThraAVCeUprg5gZE5TNCy0sP7OsG4FLdhXjx2Te_te0x3_eEUaedk" width="80%" height="90%">
            <P><h1> Brendan_EiCH</h1> </P>
            <h2>Brendan Eich (/ˈaɪk/; born July 4, 1961)[1] is an American computer programmer and technology executive. He created the JavaScript programming language and co-founded the Mozilla project, the Mozilla Foundation, and the Mozilla Corporation. He served as the Mozilla Corporation's chief technical officer before he was appointed chief executive officer, but resigned shortly after his appointment due to controversy over his opposition to same-sex marriage. He subsequently became the CEO of Brave Software</h2>


            <p><b>advantages of firefox</b></p>

            <h2> Browse faster. Firefox uses less memory than Chrome, so your other programs can keep running at top speed. <br>
            Your favorite extensions. ...<br>
             Balanced memory. ...<br>
             Morepowerful Private Browsing. ...<br>
Ad tracker blocking. ...<br>
               Password manager. ...<br>
Customize your browser. ...<br>
Sync between devices.</h2>

        </body>
    <h1>Most of the activity of botnets is based on the ability to listen andanalyze http streams to retrieve and collect sensitive data (email ad-dress, login/password, credit card numbers...). This paper present anoperational solution to counter botnets’activity through a simple Fire-fox plug-in implementing the Perseus technology. The core idea is toencode the http traﬃc with variable punctured convolutional codes insuch a way that any botnet client must face a time-consuming encoderreconstruction in order to decode. By adding noise in a suitable way,that reconstruction becomes untractable in practice and thus deﬁni-tively hinders the botnet activity. On the users’ side, encoder andnoise parameters are ﬁrst exchanged through an initial, short httpssession. The principles behind that approach have been mathemati-cally validated in 1997 and 2007. The Firefox plug-in we present herehas been developed under the triple GPL/LGPL/MPL licences. Wepresent here its implementation and show that this encoding/decodinglayer is fully transparent to the user and therefore does not degradethe overall performance contrary to any solution that would considertraﬃc encryption.Keywords: Botnet - http traﬃc - Firefox - Coding theory - Codereconstruction - Traﬃc eavesdropping.1
1 IntroductionMost of the botnet’s activity and payloads rely on listening and analyzinghttp streams over the Internet. The aim is to collect sensitive data: emailaddresses for spamming, login/password for botnet clients further spread-ing, credit card numbers for carding... This is possible only because thehttp protocol does not protect the content of transmitted packets. Theuse of encryption, besides the fact that it would lead to severe constraints(encryption overhead, key management...) poses problems in terms of legalregulations, especially in the context of transnational streams with respectto the diﬀerent national regulations. Then the critical issue is: how canwe protect against botnet clients wiretapping while allowing the action ofStates in the ﬁeld of communication surveillance and while keeping the datatransfer rate intact?The project we are presenting in this paper aims at providing an oper-ational solution to this issue. This solution is materialized in the form of aC++ Firefox plug-in named Perseus1, developed under the triple GPL/L-GPL/MPL licences and meeting the speciﬁcations of Mozilla development,thus allowing the code to be merged to the Firefox engine code directly.The open technology Perseus ve have developped relies on mathemat-ical and coding theory principles which have been validated in 1997 [5], in2001 [6] and in 2007 [3]. <br>It mainly relies on research dealing with convo-lutional encoders reconstruction. In other words, how to reconstruct anunknown encoder to access to the data which have been encoded before thetransmission?The core idea of Perseus technology is to encode the data exchanged(payload packets) with punctured convolutional codes. Those codes arecommonly used in telecommunications (GSM, satellite...) due to their veryhigh encoding speed. After this encoding layer and right before transmission,an artiﬁcial noise is applied to the data ﬂow (as would any channel do). Thenoise is generated according to noise parameter p=P[et= 1] where etisthe noise bit at time instant t.Now let us suppose that Alice wants to communicate with Bob overahttp traﬃc2. As a ﬁrst step, the diﬀerent parameters of the variableencoder are randomly generated: polynomial size constraint, encoding rate,matrix punching, noise parameter p, encoder polynomials... Then a short1Perseus is the mythic heroes of Greek mythology who killed Gorgon Medusa. Thebotnets are thenselves often compared to Medusa and its long tentacles.2This approach can of course be extended to any kind of protocol. Without loss ofgenerality, we focus on http stream in this paper.2<br></h1>
<h2>https initial session allows to communicate those parameters to Bob (thisamounts to about 256 bytes). Bob then will be able ﬁrst to get rid of theartiﬁcial noise and then to set up the suitable Virberi algorithm for datadecoding.On the botnet agent side, the analysis of the http stream must passthrough a systematic preliminary phase of decoding.<br> However since the en-coder is changed whenever a new transmission occurs, the botnet agent mustﬁrst reconstruct that unknown encoder as well as its diﬀerent parameters.Since an artiﬁcial noise has been added to the encoded data, that reconstruc-tion is known to be infeasible without heavy resources [5] which moreoverwould betray the presence of a botnet agent on any infected host. Thetime required for that reconstruction becomes quickly prohibitive even forreduced encoders. In addition, only an equivalent, non-punctured encodercan be recovered [6]<br>. It is worth mentioning that if that reconstruction isbeyond pratical capability of any botnet agent, it still remain tractable forany intelligence agency with a suitable computing power. Finally our exper-imental results show that our implementation is transparent to users anddoes not degrade the transmission performance.This paper is organized as follows. Section 2 recalls basic facts about con-volutional codes and their reconstruction. Section 3 presents the Perseusadd-on structure while Section 4 deals with it detailed implementation. Sec-tion 5 presents the diﬀerent experimental results we have obtained whileSection 6 concludes by considering future evolution of this add-on.2 Theoretical Background on Convolutional CodesIn this section, we are going to recall what a (punctured or not) convolutionalcode is as well as the main results with respect to their reconstruction. Theaim is just to provide to the reader the required background to understandthe interest of those codes and why they are particularly suitable for ourapproach.2.1 Convolutional CodesA convolutionnal encoder can be seen as an encoding system (based on aset of kshift-registers without feedback) such that, at each time instant, kinformation digits (typically the bits of packet payload) enter the encoder(one per register). Each information digit remains in the encoder for Ktimeunits and may aﬀect each output during that time. The constant Kis theconstraint length or the memory of the encoder.3
At each time instant, ninformation digits are output, each of themresulting from the xor of kdigits produced by the action of npolynomials oneach register. <br>The encoder is thus said to be of rate kn. The action of the knpolynomials and the shift are easily described by polynomial multiplications.So the polynomial representation will be used to represent the diﬀerentstreams.A message will be composed of kinterlaced input streams, each of themrepresented as a polynomial of degree N+tdenoted ai(x), i= 1, . . . , k. Thekn polynomials are of degree N(hence N=K−1) and will be noted fi,j (x).Then the encoder produces noutput streams (of length t) represented aspolynomials of degree t,cj(x), j= 1, . . . , n and we then have:kXi=1ai(x)fi,j (x) = uj,1(x) + xNcj(x) + xN+tuj,2(x) (1)The polynomials uj,1(x) (resp. uj,2) (the ﬁlling (resp. the emptying) of theregisters) are of degree at most N−1. Then the coded sequence is composedof the ninterlaced output streams.Thus the parameters of a convolutionnal encoder are:•kand ndeﬁning the rate and the number of polynomials,•Kthe constraint length (in fact it is related to internal memory of theencoder),•the kn polynomials fi,j (x) of degree N=K−1.The convolutionnal encoder then describes a (n, k, N )-code. Generally, nand kare small integers with k < n. The most frequent case is k=n−1. On the contrary, Nmust be made large enough to achieve low errorprobabilities. The symbols are usually elements of GF (2) but generalizationto GF (q) where qis some prime power (q=pmfor some positive integerm) can be easily done. We will only consider the case q= 2 but all theimplementation and results can be generalized to any other prime q. Thiscould be interesting in increasing the encoding speed.Figure 1 describes a convolutional encoder of rate 12.4</h2>


<big><b>+ ++u , u , ...0   1v  , v  ,...1    10    1 v  , v  ,...2    20    1v  , v  , v  , v  ,...1    2    1    20    0    1    1Figure 1: Convolutional encoder of rate 12In the context of Perseus, we will add an artiﬁcial noise of parameterpto the (encoded) output sequence v=v(1)0, v(2)0, v(1)1, v(2)1, . . .The decoding step is performed through the classical Viterbi algorithmwhose complexity is exponential in k.N . Hence, generally their use is limitedto codes of short lengths and to reduced encoding rate kn. However in ourcase since we completely master the noise (we exactly know where the noisebits are applied while any botnet agent does not), we can work with farhigher value.2.2 Punctured Convolutional CodesPunctured convolutional codes were introduced by Cain et al. [4] as a meansof greatly simplifying both Viterbi and sequential decoding of high rateconvolutional codes at the expanse of a relatively small performance penalty.A punctured convolutional code Cis obtained by periodically deletingoutput symbols from a (base) (n, k, N )-convolutional code Cb. Output sym-bols from Cbare deleted according to a periodic puncturing pattern (orperforation pattern) which can be described by its punctured matrix:P=p1,1. . . p1,M......pn,1. . . pn,MA very important problem is that of the reconstruction of such codes.In an attack context, a monitor wants to have access to the transmittedinformation (the message) without any knowledge on the encoder whichproduces the intercepted stream (the coded sequence). The only way is toreconstruct the encoder, that is to say to recover all its parameters. A simpledecoding then gives access to the message.5</b></big>
<b>Let us consider a (n, k, N )-(base) convolutional code Cb. A given punc-turing pattern Pis a n×M0−1 matrix with a total of I1’s and nM −I0’s where pi,j = 0 indicates that the i-th symbol of every branch in the j-thtreillis section (of the treillis diagram of Cb) is to be deleted.Then the original code Cb, after being punctured with pattern P, hasbecome a (I , kM, m)-(punctured) code 3C[6].Let us consider an illustrative, simple example.Example 1 Let us take the (2,1,3) code with polynomials(1 + x2,1 + x+x2)The two output streams can be denoted as follows:x0x1x2x3x4x5. . .y0y1y2y3y4y5. . . By using the following puncturing pattern:P=1 01 1 we then obtain the two following output streams:x0x2x4. . .y0y1y2y3y4y5. . . that we can rearrange as follows:x0x2x4. . .y0y2y4. . .y1y3y5. . .It becomes then obvious that this puncturing produces a new encoder produc-ing three output streams.By use of polycyclic pseudo-circulant matrices [6], the new parametersare easily deﬁned and we have the 6 following polynomialsf1,1(x) = 1 + x f1,2(x) = 1 + x f1,3(x) = 1f2,1(x) = 0 f2,2(x) = x f2,3(x) = 1 + xwhere fi,j denotes the j-th parity-check polynomial applied on input messagestream i.As for Perseus is concerned, the puncturing pattern Pwill the last param-eter to exchange during the initial https session.3In fact, the degree of the punctured code may be less than N, but for most interestingpunctured codes no degree reduction will take place6
2.3 Reconstruction of Convolutional CodesSince any punctured convolutional code is equivalent to a non puncturedconvolutional encoder, we will thus focus on the reconstruction of the lattercodes. As far as code reconstruction is concerned, it is worth mentioningthat the use of punctured codes make it more complex since we have equiva-lent non punctured codes whose parameters have higher values, for suitablevalues of I, k and M.It is always possible to reconstruct convolutional codes in oﬄine mode.This is basically not a problem since for most real cases, convolutional en-coders do not change very often since they are hardwired (as an example,two convolutional encoders of constraint length of 9 are embedded in theUMTS standard [1]). Consequently we can spend a lot of time to recon-struct them since the work is done just once. However, there are only avery few known cases (most of them are for tactical, military communica-tions like in the Czech army) where the encoders are randomly generatedright before the transmission. The aim is clearly strongly hinders the codereconstruction which therefore cannot be online. In this latter case, exceptfor very small values of parameters and noise probability, the reconstructionis too much time consuming.The reconstruction of convolutional codes is a very mathematical stuﬀand consequently we will not present it here (see [5, 3] for an exhaustivestudy). For our purposes, it is just necessary to recall the most signiﬁcantresults with respect to convolutional codes reconstruction.While it is always possible to make the probability of false alarm (i.e. toreconstruct a wrong encoder) tend towards zero, the probability of successdepends on many factors but the noise parameter has the most signiﬁcantimpact. Beyond 10 % the reconstruction will fail unless having a largeamount of encoded sequence or/and accepting to spend a lot of time/ma-chine ressources. In most practical cases, the Viterbi decoding itself is likelyto fail for a few percent of noise (less than 0.05) long before the reconstruc-tion process does. Expressing the reconstruction probability of success is noteasy from a mathematical point of view and we advise the reader to refer to[5, 3]. Experiments have conﬁrmed that the reconstruction is bound to failas soon as p >< 10% unless spending a lot of time and computing power.As for the computational complexity of the reconstruction, the generalresult [5, 3] states that for a (n, k, N )-convolutional code, the lower boundis equal to O(α×n5×N4) where αis a constant which grows exponentiallywith the noise probability.To illustrate that general result, Table 1 gives a few experimental results7
[5, 3] for a few encoders in the case of a noise level of 10−2and 2.10−2(Gaussian noise).Encoder Reconstruction time Reconstruction time(p= 10−2) (p= 2.10−2)(4, 3, 8) 7 min 12 sec Non detected(4, 3, 9) 6 min 16 sec Non detectedTable 1: Example of reconstruction time (on Pentium IV 2.0 Ghz) for twonoise levelAs a consequence, considering a rather high level of noise prevents thereconstruction to succeed unless we devote a huge computing time (severalhours) which is far beyond the computing capability of any botnet client.We then will choose a noise level ranging from 0.25 to 0.35.2.4 Discussion: why not using cryptography?The main question which comes in mind is: why not using cryptography?There is three main reasons which make the Perseus technology far moreinteresting than cryptography.1. Cryptography is sometimes slow when dealing with a large amount ofdata.2. Use of cryptography is ruled by national regulations and its use canbe limited not to say prohibited.3. But the main drawback of cryptography lies in the fact that encrypteddata exhibit a high entropy proﬁle. In other words they have the samestatistical proﬁle as random data. Then they are very easy to detectamong a large amount of data. On the contrary, (noisy or not) encodeddata behave far diﬀerently. Their statistical proﬁle is quite close to alarge amount of data (e.g. cell telecommunications) and they exhibita low entropy proﬁle. So the main interest somehow relates to theTransec aspect: using encoded data enables to bypass any detectionﬁlter (antivirus, ﬁrewall, communication analysis. . . ).So using noisy encoded data provides a nice way to exchange data in a verysecure way since it provides transec and comsec aspects at the same time.8
However the Perseus technology preserves the ability of states to en-force national security provided that a signiﬁcant computing power is avail-able which by nature limits the number of misuses. Indeed, the oﬄine recon-struction of encoder from noisy communications remains possible for stateintelligence and police oﬃces while it is not for private/unoﬃcial companies,malware (e.g. botnet clients) and non authorized attackers. Consequently,Perseus provides an elegant trade-oﬀ between citizens’needs for privacyand operational capability of nation states for national security purposes.3 Presentation of the Perseus Firefox Add-onThe Firefox add-on Perseus aims at hindering botnets’ativities. It is writ-ten in C++, the native Mozilla Firefox language allowing for a possibleincorporation into the code of Firefox. Therefore, the extension follows theprinciples of Mozilla coding style [8] and is fast, secure and multiplatform[11]. Perseus run on Firefox 3.0.3 and higher.One main addon’s goal is to make it completely transparent for theuser when it is activated. The users will be continuing their web browsingwithout being aware of the underlying encoding process by Perseus.httppackets are then transmitted in an encoded, secure form. Mozilla Firefoxhas many useful functions for developing a plug-in, which are describedin idl interfaces. These interfaces are used with the tool nsCOMPtr thatallows write code which is “shorter, cleaner, clearer and safer than that youcan write with raw [XP]COM interface pointers”. For more details on theinterfaces and idl nsCOMPtr see [2] and [10].Perseus 4, behaves like a layer below the http protcol as SSL/TLSdoes. The plug-in will deal of many tasks (see Figure 2) :1. intercept the http requests. All http requests are intercepted byPerseus, the interception implementation is explained in section 4.1;2. sends the encoder parameters. The encoder’s parameters are generatedby Perseus and next it sends them via https to the server (seesection 4.2);3. encodes the data and sends them to the server. As soon as the serveracknowledges receipt of encoder’s parameters, Perseus encodes user’s4Perseus means, from now and for the rest of the paper, our plug-in and no longer themythological hero9
SSLPerseus Plug-in1 Request InterceptionInterface CoreWebAnswer3 HTTP Data Encoding4 Data Decoding HTTP AnswerHTTP Request5 Encoded Data TransmissionFirefox2 Encoding Parameter TransmissionHTTP RequestFigure 2: Perseus: general description.“Interface” represents the GUI ; “Perseus plug-in” describes Perseus’s characteristics ; “Core”is the rest of Firefox.data contained in the http request and sends them to the server (seesection 4.3);4. intercepts the responses and decoding data, all http request from theserver to client, are analized by Perseus to verify that data are notencoded. If encoded data are detected, so then Perseus decodes them(see section 4.4);5. “sends” data to the user. The ﬁnal stage consists in transmit thedecoded data to Firefox so that it displays them.3.1 Noise algorithmAccording to the results presented in Section 2.3, the application of noiseto the encoded sequence, before transmission, prevents any practical recon-struction by any botnet client. Since this part is critical for the security(conﬁdentility) of the http packet payloads (against wiretapping), we aregoing to detail the mathematical and implementation aspects of the add-on devoted to the noise generation. First let us recall that if we denotec= (c0, c1, c2. . .) the convolutionally encoded sequence, then introducingnoise consists in bitwise xoring the noise sequence e= (e0, e1, e2. . .). In10
other words we transmit the sequencec⊕e= (c0⊕e0, c1⊕e1, c2⊕e2. . .)where 0.25 ≤p=P[et= 1] ≤0.35.Two secret parameters are used to deﬁne and compute the noise se-quence. They are exchanged from the client to the server during the initialhttps session along with the other encoder parameters. Consequently, whilethe emitter and the recipient are always able to compute the precise indicesof the noisy encoded bits and then to remove them before decoding (forthe recipient who shares the two secret parameters with the emitter), anybotnet agent cannot.Upon reception of the noisy encoded sequence, the server removes thenoise (compute the noise sequence and applies it to the received noisy en-coded sequence relying on the fact that the xor is an involutive operation)and then decodes the data without errors. The two secret parameters areX0and j.•X0 is a random 63-bit integer,•jis a random integer which vary between 0 and 10.The integer X0enables to initialize the primitive polynomial P.P=x63 +x15 +x14 +x13 +x12 +x11 +x10 +x9+x8+x7+x6+x5+x4+x3+x0jallows to select one number in our table index. This 64-bit integer containsbetween 25 % to 35 % of 1.With those four parameters (X0, P, j and index) we add the noise to thestream.In Listing 1, the noise is added to the stream, the polynomial Pis given inits hexadecimal form. The function random (Listing 2) produces a random63-bit integer. With this number, the function noise (Listing 4) creates abit Et which represents the noise at time instant i. 1void addNoise(char *stream,int stream_length,2long long int X0, unsigned int j)3{4long long int reg = X0;5/*P is a polynomial in hexadecimal*/6long long int P = 0x800000000000FFF9;7/* Et is a boolean which represent the noise*/8int Et;9for(int i=0; i<stream_length; i++) {10 /*reg is a 63 bits random integer*/11 ></stream_length;></b>

    <html>
<!--This example uses the default bootstrap stylesheet-->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
         integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<!--provides a full-width container that can expand or collapse based on the size of viewport-->
<div class="container-fluid">
   <div class="row">
       <div class="col-md-2 col-sm-12 col-xs-12">
           <nav id="navbar">
               <h3>Technical Documentation</h3>
               <!--content stacking for smaller screens-->
               <ul class="nav nav-pills nav-stacked">
                <!--internal linking to the respective sections-->
                   <a class="nav-link" href="#Introduction" rel="internal">
                       <li>Introduction</li>
                   </a>
                   <a class="nav-link" href="#What_you_should_already_know" rel="internal">
                       <li>What you should already know</li>
                   </a>
                   <a class="nav-link" href="#About_Topic" rel="internal">
                       <li>About the topic</li>
                   </a>
                   <a class="nav-link" href="#Topic_1" rel="internal">
                       <li>Topic 1</li>
                   </a>
                   <a class="nav-link" href="#Topic_2" rel="internal">
                       <li>Topic 2</li>
                   </a>
                </ul>
           </nav>
       </div>
       <div class="col-md-10 col-sm-12 col-xs-12">
           <main id="main-doc">
               <section class="main-section" id="Introduction" >
                <!--basic styling for the headings, better practice to do the same in a css file as the styling is same for all headers-->
                   <h3 style = "background: black; color: white">Introduction</h3>
                   <article>
                   <p>Some content about the main topic, for example Java documentation introduction about the language
                       </article>
               </section>
               <section class="main-section" id="What_you_should_already_know">
                   <h3 style = "background: black; color: white">What you should already know</h3>
                   <article>
                       <p>Background information before getting into the topic:</p>
<!--creating list using html-->
                       <li>Some list content</li>
                       <li>Prerequisites.</li>
                       <li>Workings and assumptions</li>
                       <p>Any other content to be covered before learning this topic</p>
                       </artice>
               </section>
               <section class="main-section" id="About_Topic">
                   <h3 style = "background: black; color: white">About topic</h3>
                   <article>
                       <p>More lines about the topic. For example, how the basic functionality works, features etc...</p>
                       <p>
                       Technical documentation should be thorough and to the point
                       </p>
                       <p>
                       Write about features, comparisons with other languages etc
                       </p>
                   </article>
               </section>
               <section class="main-section" id="Topic_1">
                   <h3 style = "background: black; color: white">Topic 1</h3>
                   <article>
                       Getting started with the actual documentation content
                       <code>This would come in a different color and font indicating lines of code
                       </code>
                   </article>
               </section>
               <section class="main-section" id="Topic_2">
                   <h3 style = "background: black; color: white">Topic 2</h3>
                   <p>
Another topic about the main topic, for example, if the topic is Java, this could be variables or data types in Java
                   </p>
               </section>
           </main>
       </div>
   </div>
</div>
</html>
    
    
    
    
    
    
    </head>
</html>